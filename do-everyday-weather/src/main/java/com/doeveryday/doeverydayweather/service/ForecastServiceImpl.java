package com.doeveryday.doeverydayweather.service;

import com.byteowls.jopencage.model.JOpenCageComponents;
import com.doeveryday.doeverydayweather.exceptions.ApiWeatherConnectionException;
import com.doeveryday.doeverydayweather.model.*;
import com.doeveryday.doeverydayweather.urlcreator.ForecastUrlBuild;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import tk.plogitech.darksky.forecast.APIKey;
import tk.plogitech.darksky.forecast.GeoCoordinates;
import tk.plogitech.darksky.forecast.model.Forecast;
import tk.plogitech.darksky.forecast.model.Latitude;
import tk.plogitech.darksky.forecast.model.Longitude;

import java.io.IOException;
import java.net.URL;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
import static com.fasterxml.jackson.databind.MapperFeature.AUTO_DETECT_GETTERS;
import static com.fasterxml.jackson.databind.MapperFeature.REQUIRE_SETTERS_FOR_GETTERS;
import static com.fasterxml.jackson.databind.SerializationFeature.INDENT_OUTPUT;

@Slf4j
@Service
public class ForecastServiceImpl implements ForecastService {

    public static final long ONE_HOUR = 3600L;
    private final GeoLocationService geoLocationService;
    private final Map<WeatherProperties, ForecastDate> propertiesForecastMap = new HashMap<>();

    @Value("${default.geolocation.longitude}")
    private Double longitude;
    @Value("${default.geolocation.latitude}")
    private Double latitude;
    @Value("${darksky.api.key}")
    private String key;

    public ForecastServiceImpl(GeoLocationService geoLocationService) {
        this.geoLocationService = geoLocationService;
    }

    /**
     * Properties base on properties define in properties file
     * City: auto-generated by Latitude, Longitude
     * Latitude: default.geolocation.latitude
     * Longitude: default.geolocation.longitude
     * Units: Si(International System of Units)
     * Language: EN
     */
    public WeatherProperties getWeatherPropertiesBasedOnApplicationProp(){
        return WeatherProperties.builder()
                .language(ForecastUrlBuild.Language.en)
                .latitude(latitude)
                .longitude(longitude)
                .units(ForecastUrlBuild.Units.si)
                .build();
    }

    @Override
    public CurrentlyForecast getCurrentWeather(WeatherProperties properties) {
        JOpenCageComponents location = geoLocationService.getFirstResult(properties);
        return new CurrentlyForecast(
                new Location(location.getCity(), location.getCountry()),
                getForecast(properties).getCurrently());
    }

    @Override
    public HourlyForecast getHourlyForecast(WeatherProperties properties) {
        JOpenCageComponents location = geoLocationService.getFirstResult(properties);
        return new HourlyForecast(
                new Location(location.getCity(), location.getCountry()),
                getForecast(properties).getHourly());
    }

    @Override
    public DailyForecast getDailyForecast(WeatherProperties properties) {
        JOpenCageComponents location = geoLocationService.getFirstResult(properties);
        return new DailyForecast(
                new Location(location.getCity(), location.getCountry()),
                getForecast(properties).getDaily());
    }

    @Override
    public FullForecast getFullForecast(WeatherProperties properties){
        JOpenCageComponents location = geoLocationService.getFirstResult(properties);
        return new FullForecast(
                getForecast(properties),
                new Location(location.getCity(), location.getCountry()));
    }

    private Forecast getForecast(WeatherProperties properties) {
        if (propertiesForecastMap.containsKey(properties)){
            Instant lastShotToApi = propertiesForecastMap.get(properties).getTimeGetThisWeather();
            if (lastShotToApi.plusSeconds(ONE_HOUR).isAfter(Instant.now())){
                return propertiesForecastMap.get(properties);
            }
        }

        GeoCoordinates geoCoordinates = new GeoCoordinates(
                new Longitude(properties.getLongitude()),
                new Latitude(properties.getLatitude()));
        //        Building URL
        URL requestUrl = new ForecastUrlBuild()
                .language(properties.getLanguage())
                .key(new APIKey(key))
                .location(geoCoordinates)
                .units(properties.getUnits())
                .extendHourly()
                .build();

        ObjectMapper objectMapper = objectMapper();

//        Mapping JSON to Forecast
        try {
            Forecast actualForecast = objectMapper.readValue(requestUrl, Forecast.class);

            if (propertiesForecastMap.containsKey(properties)){
                propertiesForecastMap.replace(properties, new ForecastDate(actualForecast));
            }
            else {
                propertiesForecastMap.put(properties, new ForecastDate(actualForecast));
            }
            return actualForecast;
        } catch (IOException e) {
            e.printStackTrace();
            throw new ApiWeatherConnectionException("Error while getting forecast...");
        }
    }

    /**
     * It setting mapper configurer for understand Forecast.class
     */
    private ObjectMapper objectMapper() {
        ObjectMapper objectMapper = new ObjectMapper();

        objectMapper.registerModule(new JavaTimeModule());
        objectMapper.enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);
        objectMapper.configure(REQUIRE_SETTERS_FOR_GETTERS, false);
        objectMapper.configure(AUTO_DETECT_GETTERS, true);
        objectMapper.configure(INDENT_OUTPUT, true);
        objectMapper.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        return objectMapper;
    }

//    private void checkDataTopicality() {
//        if (forecast == null) {
//            updateGeoCoordinates();
//        } else if (!forecast.getLatitude().value().equals(this.latitude) ||
//                !forecast.getLongitude().value().equals(this.longitude)) {
//            updateGeoCoordinates();
//        } else if (lastShotToDb.atZone(ZoneOffset.UTC).getHour() != Instant.now().atZone(ZoneOffset.UTC).getHour()) {
//            updateGeoCoordinates();
//        }
//    }
}
